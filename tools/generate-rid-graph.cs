#:package System.Text.Json@9.0.0

// RID Graph Generator for MinRT
// Downloads runtime.json from Microsoft.NETCore.Platforms and generates RidGraph.Generated.cs
//
// Usage: dotnet run generate-rid-graph.cs [output-path]
// Default output: ../MinRT.NuGet/RidGraph.Generated.cs

using System.Text.Json;

var outputPath = args.Length > 0 ? args[0] : null;

// If no path specified or relative, resolve from current working directory
if (string.IsNullOrEmpty(outputPath))
{
    outputPath = Path.Combine(Directory.GetCurrentDirectory(), "..", "MinRT.NuGet", "RidGraph.Generated.cs");
}

outputPath = Path.GetFullPath(outputPath);

Console.WriteLine("RID Graph Generator for MinRT");
Console.WriteLine("==============================");

// Download runtime.json from dotnet/runtime repo
const string runtimeJsonUrl = "https://raw.githubusercontent.com/dotnet/runtime/main/src/libraries/Microsoft.NETCore.Platforms/src/runtime.json";

Console.WriteLine($"Downloading runtime.json from {runtimeJsonUrl}...");

using var httpClient = new HttpClient();
var json = await httpClient.GetStringAsync(runtimeJsonUrl);

Console.WriteLine($"Downloaded {json.Length:N0} bytes");

// Parse the JSON
using var doc = JsonDocument.Parse(json);
var runtimes = doc.RootElement.GetProperty("runtimes");

var ridImports = new Dictionary<string, List<string>>();

foreach (var runtime in runtimes.EnumerateObject())
{
    var rid = runtime.Name;
    var imports = new List<string>();
    
    if (runtime.Value.TryGetProperty("#import", out var importArray))
    {
        foreach (var import in importArray.EnumerateArray())
        {
            imports.Add(import.GetString()!);
        }
    }
    
    ridImports[rid] = imports;
}

Console.WriteLine($"Parsed {ridImports.Count} RID entries");

// Generate C# code
var sb = new System.Text.StringBuilder();

sb.AppendLine("// <auto-generated>");
sb.AppendLine("// This file was generated by tools/generate-rid-graph.cs");
sb.AppendLine($"// Source: {runtimeJsonUrl}");
sb.AppendLine("// Do not edit manually. Run 'dotnet run tools/generate-rid-graph.cs' to regenerate.");
sb.AppendLine("// </auto-generated>");
sb.AppendLine();
sb.AppendLine("#nullable enable");
sb.AppendLine();
sb.AppendLine("namespace MinRT.NuGet;");
sb.AppendLine();
sb.AppendLine("public static partial class RidGraph");
sb.AppendLine("{");
sb.AppendLine("    private static readonly Dictionary<string, string[]> s_ridImports = new(StringComparer.OrdinalIgnoreCase)");
sb.AppendLine("    {");

// Sort for deterministic output
foreach (var kvp in ridImports.OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase))
{
    if (kvp.Value.Count == 0)
    {
        sb.AppendLine($"        [\"{Escape(kvp.Key)}\"] = [],");
    }
    else
    {
        var imports = string.Join(", ", kvp.Value.Select(v => $"\"{Escape(v)}\""));
        sb.AppendLine($"        [\"{Escape(kvp.Key)}\"] = [{imports}],");
    }
}

sb.AppendLine("    };");
sb.AppendLine();
sb.AppendLine("    private static partial IReadOnlyDictionary<string, string[]> GetRidImports() => s_ridImports;");
sb.AppendLine("}");

// Ensure output directory exists
var outputDir = Path.GetDirectoryName(outputPath);
if (!string.IsNullOrEmpty(outputDir))
{
    Directory.CreateDirectory(outputDir);
}

await File.WriteAllTextAsync(outputPath, sb.ToString());

Console.WriteLine($"Generated {outputPath}");
Console.WriteLine($"Total RIDs: {ridImports.Count}");

// Print some stats
var baseRids = ridImports.Where(x => x.Value.Count == 0).Select(x => x.Key).ToList();
Console.WriteLine($"Base RIDs (no imports): {baseRids.Count}");
foreach (var rid in baseRids.Take(10))
{
    Console.WriteLine($"  - {rid}");
}
if (baseRids.Count > 10)
{
    Console.WriteLine($"  ... and {baseRids.Count - 10} more");
}

Console.WriteLine();
Console.WriteLine("Done!");

static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
